# Copyright (c) 2007-2020 Andy Maleh
# 
# Permission is hereby granted, free of charge, to any person obtaining
# a copy of this software and associated documentation files (the
# "Software"), to deal in the Software without restriction, including
# without limitation the rights to use, copy, modify, merge, publish,
# distribute, sublicense, and/or sell copies of the Software, and to
# permit persons to whom the Software is furnished to do so, subject to
# the following conditions:
# 
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

module Glimmer
  module SWT
    # Proxy for org.eclipse.swt.graphics.Image
    #
    # Invoking `#swt_image` returns the SWT Image object wrapped by this proxy
    #
    # Follows the Proxy Design Pattern
    class ImageProxy
      class << self
        def create(*args)
          if args.size == 1 && args.first.is_a?(ImageProxy)
            args.first
          else
            new(*args)
          end
        end
      end
      
      include_package 'org.eclipse.swt.graphics'
      
      attr_reader :file_path, :jar_file_path, :image_data, :swt_image
      
      # Initializes a proxy for an SWT Image object
      #
      # Takes the same args as the SWT Image class
      # Alternatively, takes a file path string or a uri:classloader file path string (generated by JRuby when invoking `File.expand_path` inside a JAR file)
      # and returns an image object.
      def initialize(*args)
        @args = args
        options = @args.last.is_a?(Hash) ? @args.delete_at(-1) : {}
        options[:swt_image] = @args.first if @args.size == 1 && @args.first.is_a?(Image)
        @file_path = @args.first if @args.size == 1 && @args.first.is_a?(String)
        @args = @args.first if @args.size == 1 && @args.first.is_a?(Array)
        if options&.keys&.include?(:swt_image)
          @swt_image = options[:swt_image]
          @image_data = @swt_image.image_data
        elsif @file_path
          @image_data = ImageData.new(input_stream || @file_path)
          @swt_image = Image.new(DisplayProxy.instance.swt_display, @image_data)
        else
          @swt_image = Image.new(*@args)
          @image_data = @swt_image.image_data
        end        
      end
      
      def input_stream
        if @file_path.start_with?('uri:classloader')
          @jar_file_path = @file_path
          file_path = @jar_file_path.sub(/^uri\:classloader\:/, '').sub('//', '/') # the latter sub is needed for Mac
          object = java.lang.Object.new
          file_input_stream = object.java_class.resource_as_stream(file_path)
        else
          file_input_stream = java.io.FileInputStream.new(@file_path)
        end      
        java.io.BufferedInputStream.new(file_input_stream) if file_input_stream
      end

      def scale_to(width, height)
        scaled_image_data = image_data.scaledTo(width, height)
        device = swt_image.device
        swt_image.dispose
        @swt_image = Image.new(device, scaled_image_data)
        @image_data = @swt_image.image_data
        self
      end
      
      def method_missing(method, *args, &block)
        swt_image.send(method, *args, &block)
      rescue => e
        Glimmer::Config.logger.debug {"Neither ImageProxy nor #{swt_image.class.name} can handle the method ##{method}"}
        super
      end
      
      def respond_to?(method, *args, &block)
        super || swt_image.respond_to?(method, *args, &block)
      end      
    end
  end
end
